$date
	Mon Nov 13 22:13:07 2023
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module bram_testbench $end
$var wire 32 ! out [31:0] $end
$var reg 1 " clock $end
$var reg 11 # raddr [10:0] $end
$var reg 11 $ waddr [10:0] $end
$var reg 32 % wdata [31:0] $end
$var reg 1 & wren $end
$scope module dut $end
$var wire 1 " clock $end
$var wire 11 ' raddr [10:0] $end
$var wire 11 ( waddr [10:0] $end
$var wire 32 ) wdata [31:0] $end
$var wire 1 & wren $end
$var wire 8 * out3 [7:0] $end
$var wire 8 + out2 [7:0] $end
$var wire 8 , out1 [7:0] $end
$var wire 8 - out0 [7:0] $end
$var reg 32 . out [31:0] $end
$var reg 9 / raddr0 [8:0] $end
$var reg 9 0 raddr1 [8:0] $end
$var reg 9 1 raddr2 [8:0] $end
$var reg 9 2 raddr3 [8:0] $end
$var reg 9 3 waddr0 [8:0] $end
$var reg 9 4 waddr1 [8:0] $end
$var reg 9 5 waddr2 [8:0] $end
$var reg 9 6 waddr3 [8:0] $end
$var reg 8 7 wdata0 [7:0] $end
$var reg 8 8 wdata1 [7:0] $end
$var reg 8 9 wdata2 [7:0] $end
$var reg 8 : wdata3 [7:0] $end
$var reg 1 ; wren0 $end
$var reg 1 < wren1 $end
$var reg 1 = wren2 $end
$var reg 1 > wren3 $end
$scope module ram0 $end
$var wire 1 " clock $end
$var wire 9 ? raddr [8:0] $end
$var wire 9 @ waddr [8:0] $end
$var wire 8 A wdata [7:0] $end
$var wire 1 ; wren $end
$var reg 8 B out [7:0] $end
$upscope $end
$scope module ram1 $end
$var wire 1 " clock $end
$var wire 9 C raddr [8:0] $end
$var wire 9 D waddr [8:0] $end
$var wire 8 E wdata [7:0] $end
$var wire 1 < wren $end
$var reg 8 F out [7:0] $end
$upscope $end
$scope module ram2 $end
$var wire 1 " clock $end
$var wire 9 G raddr [8:0] $end
$var wire 9 H waddr [8:0] $end
$var wire 8 I wdata [7:0] $end
$var wire 1 = wren $end
$var reg 8 J out [7:0] $end
$upscope $end
$scope module ram3 $end
$var wire 1 " clock $end
$var wire 9 K raddr [8:0] $end
$var wire 9 L waddr [8:0] $end
$var wire 8 M wdata [7:0] $end
$var wire 1 > wren $end
$var reg 8 N out [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx N
b0 M
b0 L
b0 K
bx J
b0 I
b0 H
b0 G
bx F
b0 E
b0 D
b0 C
bx B
b0 A
b0 @
b0 ?
0>
0=
0<
0;
b0 :
b0 9
b0 8
b0 7
b0 6
b0 5
b0 4
b0 3
b0 2
b0 1
b0 0
b0 /
bx .
bx -
bx ,
bx +
bx *
b0 )
b0 (
b0 '
0&
b0 %
b0 $
b0 #
0"
bx !
$end
#10
1>
1=
1<
1;
1&
#50
b0 !
b0 .
b0 -
b0 B
b0 ,
b0 F
b0 +
b0 J
b0 *
b0 N
1"
#100
0"
#110
b1 6
b1 L
b1 5
b1 H
b1 4
b1 D
b1 3
b1 @
b1 2
b1 K
b1 1
b1 G
b1 0
b1 C
b1 /
b1 ?
b100 $
b100 (
b100 #
b100 '
#150
1"
#200
0"
#210
b10010 9
b10010 I
b110100 8
b110100 E
b1010110 7
b1010110 A
b1111000 :
b1111000 M
b0 6
b0 L
b0 2
b0 K
b10010001101000101011001111000 %
b10010001101000101011001111000 )
b11 $
b11 (
b11 #
b11 '
#250
b10010001101000101011001111000 !
b10010001101000101011001111000 .
b1010110 -
b1010110 B
b110100 ,
b110100 F
b10010 +
b10010 J
b1111000 *
b1111000 N
1"
#300
0"
#310
b1111000000100100011010001010110 !
b1111000000100100011010001010110 .
0>
0=
0<
0;
b1 2
b1 K
0&
b100 #
b100 '
#350
b100100011010001010110 !
b100100011010001010110 .
b0 *
b0 N
1"
#400
0"
#410
b0 2
b0 K
b0 1
b0 G
b0 0
b0 C
b0 /
b0 ?
b0 #
b0 '
#450
b1111000000000000000000000000000 !
b1111000000000000000000000000000 .
b0 -
b0 B
b0 ,
b0 F
b0 +
b0 J
b1111000 *
b1111000 N
1"
#500
0"
#510
